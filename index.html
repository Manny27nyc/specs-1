<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        subtitle: "A protocol for data matching on the Web",
        shortName: "reconciliation-api-10",
        pluralize: true,
        wg: "Entity Reconciliation Community Group",
        wgPublicList: "public-reconciliation",
        wgURI: "https://www.w3.org/community/reconciliation/",
        github: {
           repoURL: "https://github.com/reconciliation-api/specs",
           branch: "master"
        },
        editors: [
          {
            name: "Antonin Delpeuch",
            url: "http://antonin.delpeuch.eu/",
            orcid: "0000-0002-8612-8827",
            company: "University of Oxford",
            companyURL: "https://www.ox.ac.uk/"
          },
          {
            name: "Adrian Pohl",
            url: "https://lobid.org/team/ap",
            orcid: "0000-0001-9083-7442",
            company: "hbz, Cologne",
            companyURL: "https://www.hbz-nrw.de/"
          },
          {
            name: "Fabian Steeg",
            url: "http://fsteeg.com",
            orcid: "0000-0001-8829-1989",
            company: "hbz, Cologne",
            companyURL: "https://www.hbz-nrw.de/"
          },
          // add yourself here!
          {
            name: "Add Yourself Here!"
          }
        ],
      };
    </script>
    <title>Reconciliation Service API</title>
  </head>
  <body>
    <h1>Reconciliation Service API</h1>
    <section id='abstract'>
      <p>
        This document describes the reconciliation service API as supported by OpenRefine 3.x.
        It is intended as a comprehensive and definitive specification of this API in its given state.
        Further improvements to the API, to be discussed in the W3C Entity Reconciliation Community Group,
        will be specified in the next iteration of this document.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This report was published by the <a href="http://www.w3.org/community/reconciliation/">Entity Reconciliation Community Group</a>.
        It is not a W3C Standard nor is it on the W3C Standards Track.
        Please note that under the <a href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a> there is a limited opt-out and other conditions apply.
        Learn more about <a href="http://www.w3.org/community/">W3C Community and Business Groups</a>.
      </p>
      <p>
        Members of the Community Group are encouraged to contribute to this document by
        documenting the current behaviour of the reconciliation API.
        The <a href="https://github.com/w3c/respec/wiki/ReSpec-Editor's-Guide">ReSpec Editor's Guide</a>
        can be used to learn more about the markup to use in this document.
      </p>
    </section>
    <section class="informative">
      <h2>Introduction</h2>
      <section>
        <h3>Data Matching on the Web</h3>
        <p class="ednote">
          TODO: We could write a quick introduction to the problem the API intends to solve. Rule out similar use cases such as text annotation.
        </p>
      </section>
      <section>
        <h3>History of the Reconciliation API</h3>
        <p class="ednote">
          TODO: A quick history of how the API came into being and how it evolved.
        </p>
      </section>
      <section>
        <h3>External Resources</h3>
        <p class="ednote">
          TODO: links to libraries, validators, user documentation. Our <a href="https://reconciliation-api.github.io/census/">census</a> could be used for that.
        </p>
      </section>
      <section>
        <h3>Conventions Used in This Document</h3>
        <p>
            The key words MAY, MUST, MUST NOT, RECOMMENDED, SHOULD, and SHOULD NOT in this document are to be interpreted as described in
            <a href="https://tools.ietf.org/html/bcp14">BCP 14</a> [[RFC2119]] [[RFC8174]] when, and only when, they appear in all capitals, as shown here.
        </p>
      </section>
    </section>
    <section>
      <h2>Core Concepts</h2>
      <p>
        This section documents the data model behind the reconciliation API.
        A reconciliation service lets users match their data against <a>entities</a>
        exposed by the service. Matching can be refined by filtering by <a>type</a>
        or <a>properties</a> with <a>property values</a>.
        The purpose of this section is to define these notions. Their relationships
        are summarized in the <a href="#uml_diagram">UML diagram</a>.
      </p>
      <figure id="uml_diagram">
        <img src="img/uml_diagram.svg" alt="UML diagram of the data model" />
        <figcaption>UML diagram of the data model</figcaption>
      </figure>
      <section>
        <h3 data-link-for="entities">Entities</h3>
        <p>
           An <dfn>entity</dfn> is a record in the data source exposed by the service.
           It comprises the following fields:
           <ul>
              <li>an <emph>identifier</emph>, which is a non-empty string. This identifier must be unique among all entities;</li>
              <li>a <emph>name</emph>, which is also a non-empty string;</li>
              <li>a list of <a>types</a>, possibly empty;</li>
              <li>for each <a>property</a>, a set of <a>property values</a>, possibly empty.</li>
           </ul>
        </p>
        <p>
           Reconciliation services can define in their <a>manifest</a> a <dfn>view template</dfn> which
           associates to each entity a corresponding URI, by inserting its identifier in the template.
           A view template is a string which contains the <code>{{id}<!-- -->}</code> substring.
           For each entity, replacing <code>{{id}<!-- -->}</code> in the template by the entity's identifier
           MUST result in a valid URI [[RFC2396]].
        </p>
      </section>
      <section>
        <h3 data-link-for="types">Types</h3>
        <p>
          A <dfn>type</dfn> represents a category of <a>entities</a>.
          It comprises the following fields:
          <ul>
             <li>an <emph>identifier</emph>, which is a non-empty string. This identifier must be unique among all types;</li>
             <li>a <emph>name</emph>, which is a non-empty string.</li>
          </ul>
        </p>
      </section>
      <section>
        <h3 data-link-for="properties">Properties</h3>
        <p>
          A <dfn>property</dfn> represents a type of attribute that entities can have in the data source.
          It comprises the following fields:
          <ul>
            <li>an <emph>identifier</emph>, which is a non-empty string. This identifier must be unique among all properties;</li>
            <li>a <emph>name</emph>, which is a non-empty string.</li>
          </ul>
        </p>
      </section>
      <section>
        <h3 data-link-for="property values">Property Values</h3>
        <p>
          A <dfn>property value</dfn> can be any of the following:
          <ul>
             <li>A string;</li>
             <li>A boolean;</li>
             <li>An integer;</li>
             <li>A floating-point value;</li>
             <li>A <dfn>reconciled value</dfn>, consisting of an identifier and a name, both being strings.</li>
          </ul>
        </p>
      </section>
      <section>
        <h3 data-link-for="spaces">Identifier and Schema Spaces</h3>
        <p>
          The <dfn>identifier space</dfn> is ...
        </p>
        <p>
          The <dfn>schema space</dfn> is ...
        </p>
      </section>
    </section>
    <section>
      <h2>Service Definition</h2>
      <p>
        This section documents how reconciliation services are exposed as HTTP(S) services and
        how they can announce the features of the API they implement.
      </p>
      <p>
        A <dfn>reconciliation service</dfn> consists of…
      </p>
      <section>
        <h3>HTTP(S) Access</h3>
        <p class="ednote">
          Points to specify here: GET/POST, HTTP status codes, HSTS, redirects…
        </p>
      </section>
      <section>
        <h3>Cross-Origin Access</h3>
        <p>
           All HTTP(S) endpoints exposed by the service MUST support JSONP [[RFC6902]], which
           enables web-based clients to access the service from a different domain.
        </p>
        <p class="note">
           As of version 3.2, OpenRefine uses JSONP to access reconciliation services
           from its user interface. This applies to the service manifest and the suggest
           services. Calls to the preview service are made via an <code>&lt;iframe&gt;</code>
           from the front-end and do not require cross-origin control.
           Other calls (reconciliation queries and data extension queries) are made from the back-end
           and therefore do not require cross-origin control either. Still, this document states
           that all endpoints MUST support JSONP, since the service should not rely on the
           client's architecture.
        </p>
        <p>
           In addition, endpoints SHOULD also enable access by CORS [[cors]] to enable
           newer web-based clients to access the service without exposing themselves to
           untrusted third-party code.
        </p>
        <p>
           This can be achieved by adding the following HTTP headers to all HTTP responses
           produced by the service:
           <pre>
             Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
             Access-Control-Allow-Headers: Origin, Accept, Content-Type, X-Requested-With, X-CSRF-Token
             Access-Control-Allow-Origin: *
           </pre>
        </p>
        <p class="note">
           CORS provides a safer way to expose cross-origin web services and SHOULD therefore be
           supported by reconciliation services, in the interest of other clients and potentially
           of newer versions of OpenRefine.
        </p>
      </section>
      <section>
        <h3>Service Manifest</h3>
        <p>A <dfn>manifest</dfn> is ...</p>
      </section>
    </section>
    <section>
      <h2>Reconciliation Queries</h2>
      <p>
        This section specifies how clients can send reconciliation queries to services and
        how services respond to them.
      </p>
      <section>
        <h3>Reconciliation HTTP Requests</h3>
        <p>
          A reconciliation service MUST support HTTP POST requests with
          <code>application/x-www-form-urlencoded</code> bodies containing a
          <a>reconciliation query batch</a> in a form element named <code>queries</code>.
        </p>
        <p>
          <pre class="example nohighlight">POST / queries=&lt;URL-encoded reconciliation query batch&gt;</pre>
        </p>
        <p>
          A reconciliation service SHOULD support HTTP GET requests with a
          <a>reconciliation query batch</a> in a query string parameter named <code>queries</code>.
        </p>
        <p>
          <pre class="example nohighlight">GET /?queries=&lt;URL-encoded reconciliation query batch&gt;</pre>
        </p>
      </section>
      <section>
        <h3>Structure of a Reconciliation Query</h3>
        <p>
          A <dfn>reconciliation query</dfn> consists of:
          <ul>
            <li>A query string, consisting of a non-empty string, which is mandatory;</li>
            <li>Optionally, a list of <a>types</a>;</li>
            <li>Optionally, a limit, consisting of a positive integer;</li>
            <li>Optionally, a list of pairs of <a href='#properties'>property</a> identifiers and <a>property values</a>;</li>
            <li>Optionally, a type strictness parameter, which can be one of the strings <code>"should"</code>, <code>"all"</code> or <code>"any"</code>.</li>
          </ul>
        </p>
        <p>
          A <dfn>reconciliation query batch</dfn> is a set of <a>reconciliation queries</a> indexed by string identifiers.
        </p>
        <p>
          Minimal example of a <a>reconciliation query batch</a> with mandatory fields only:
          <pre data-include="examples/reconciliation-query-batch/valid/example-min.json" class="example json"></pre>
        </p>
        <p>
          Full example of a <a>reconciliation query batch</a> with all optional fields:
          <pre data-include="examples/reconciliation-query-batch/valid/example-full.json" class="example json"></pre>
        </p>
        <p>
          A <a href="#reconciliation-query-batch-json-schema">JSON schema to validate the serialization of a query batch</a> is available.
        </p>
      </section>
      <section>
        <h3>Reconciliation Candidates</h3>
        <p>
          A <dfn>reconciliation candidate</dfn> consists of:
          <ul>
            <li>An <a>entity</a>;</li>
            <li>A <dfn>reconciliation score</dfn>, which is a floating-point value or integer;</li>
            <li>A matching decision, which is a boolean.</li>
          </ul>
        </p>
      </section>
      <section>
        <h3>Sending Reconciliation Queries to a Service</h3>
        <p>
          A <dfn>reconciliation result</dfn> is a set of reconciliation candidates.
        </p>
        <p>
          A <dfn>reconciliation result batch</dfn> is a set of <a>reconciliation results</a> indexed by string identifiers of the corresponding <a>reconciliation query batch</a>.
        </p>
        <p>
          A <a href="#reconciliation-result-batch-json-schema">JSON schema to validate the serialization of a reconciliation result batch</a> is available.
        </p>
      </section>
    </section>
    <section>
      <h2>Preview Service</h2>
      <p>
        This section specifies how reconciliation services can provide embeddable HTML previews
        of their entities, which clients can display in their user interface.
      </p>
    </section>
    <section>
      <h2>Suggest Services</h2>
      <p>
        This section specifies how reconciliation services can provide auto-complete
        endpoints for their <a>entities</a>, <a>properties</a> and <a>types</a>.
      </p>

    </section>
    <section>
      <h2>Data Extension Service</h2>
      <p>
        This section specifies how reconciliation services can let clients fetch the values
        of some <a>properties</a> on a selection of <a>entities</a>.
      </p>
      <p>
        A data extension service MUST support <a>data extension query requests</a>.
      </p>
      <p>
        A data extension service SHOULD provide <a>data extension property proposals</a>.
      </p>
      <p>
        A data extension service MAY support <a>data extension property settings</a>.
      </p>
      <section>
        <h3>Data Extension Metadata</h3>
        <p>
          The <dfn>data extension metadata</dfn> consists of:
          <ul>
            <li>An object in the service <a>manifest</a> in the <code>extend</code> field;</li>
            <li>Optionally, the <code>service_url</code> and <code>service_path</code> for <a>data extension property proposals</a>;</li>
            <li>Optionally, a list of <a>data extension property settings</a>.</li>
          </ul>
        </p>
        <p>
          A <dfn>data extension property setting</dfn> consists of:
          <ul>
            <li>A name;</li>
            <li>A label;</li>
            <li>A default value;</li>
            <li>A help text;</li>
            <li>A type, which can be one of the strings <code>"number"</code>, <code>"text"</code>, <code>"checkbox"</code>, or <code>"select"</code>;</li>
            <li>If <code>type</code> is <code>select</code>, a list of property setting choices.</li>
          </ul>
        </p>
        <p>
          Example of <a>data extension metadata</a> with all optional fields:
          <pre data-include="examples/data-extension-metadata/valid/example-full.json" class="example json"></pre>
        </p>
      </section>
      <section>
        <h3>Data Extension Property Proposals</h3>
        <p>
          A <dfn>data extension property proposal</dfn> service returns <a>properties</a> for a given <a>type</a> identifier.
        </p>
        <p>
          The service MUST support HTTP GET requests with a `type` query string parameter.
        </p>
        <p>
          The service SHOULD support an optional `limit` query string parameter to control the number of proposed properties.
        </p>
        <p>
          The service URL and path are declared in the <a>data extension metadata</a> of the service <a>manifest</a>.
        </p>
        <p>
          <pre class="example nohighlight">GET /properties?type=&lt;type identifier&gt;[&amp;limit=&lt;limit&gt;]</pre>
        </p>
        <p>
          A <dfn>data extension property proposal response</dfn> consists of:
          <ul>
            <li>Optionally, the requested limit;</li>
            <li>The requested <a>type</a> identifier;</li>
            <li>An array of proposed <a>properties</a>.</li>
          </ul>
        </p>
        <p>
          Example of a <a>data extension property proposal</a> response:
          <pre data-include="examples/data-extension-property-proposal/valid/response.json" class="example json"></pre>
        </p>
      </section>
      <section>
        <h3>Data Extension Query Requests</h3>
        <p>
         A <dfn>data extension query request</dfn> lets clients fetch the values
         of some <a>properties</a> on a selection of <a>entities</a>.
        </p>
        <p>
          A data extension service MUST declare <a>data extension metadata</a> in the service <a>manifest</a>.
        <p>
          A data extension service MUST support HTTP POST requests with
          <code>application/x-www-form-urlencoded</code> bodies containing a
          <a>data extension query</a> in a form element named <code>extend</code>.
        </p>
        <p>
          <pre class="example nohighlight">POST / extend=&lt;URL-encoded data extension query&gt;</pre>
        </p>
        <p>
          A data extension service SHOULD support HTTP GET requests with a
          <a>data extension query</a> in a query string parameter named <code>extend</code>.
        </p>
        <p>
          <pre class="example nohighlight">GET /?extend=&lt;URL-encoded data extension query&gt;</pre>
        </p>
        <p>
          A <dfn>data extension query</dfn> consists of:
          <ul>
            <li>A list of <a>entity</a> identifiers;</li>
            <li>A list of <a>properties</a> with optional <a href="#data+extension+property+setting">settings</a>.</li>
          </ul>
        </p>
        <p>
          Example of a <a>data extension query</a>:
          <pre data-include="examples/data-extension-query/valid/example-full.json" class="example json"></pre>
        </p>
      </section>
      <section>
        <h3>Data Extension Responses</h3>
        <p>
          A <dfn>data extension response</dfn> consists of <a href="#data+extension+response+metadata">metadata</a>
          and <a href="#data+extension+response+rows">rows</a>.
        </p>
        <p>
          The <dfn id="data+extension+response+metadata">metadata</dfn> contains the <a>properties</a> used for data
          extension, as requested in the <a>data extension query</a>. If properties represent <a>reconciled values</a>,
          they MAY specify a <a>type</a> in the metadata.
        </p>
        <p>
          The <dfn id="data+extension+response+rows">rows</dfn> object contains, for each <a>entity</a> identifier in the
          <a>data extension query</a>, for each <a>property</a> identifier in the
          <a href="#data+extension+response+metadata">metadata</a>, the <a>property values</a> of that property in that entity.
          If the property values are <a>reconciled values</a>, their identifiers MUST be in the service's <a>identifier space</a>.
        </p>
        <p>
          Response example for the <a>data extension query</a> from the previous example:
          <pre data-include="examples/data-extension-response/valid/example-full.json" class="example json"></pre>
        </p>
      </section>
    </section>
    <section class="appendix">
      <h2>JSON Schemas</h2>
        <p>
          This appendix provides JSON schemas [[json-schema]] which can be used to validate the JSON serialization
          of various elements as specified by these specifications.
        </p>
      <section>
        <h3>Manifest Schema</h3>
        <p>
          The <a href="schemas/manifest.json">manifest schema</a> can be used to validate a service <a>manifest</a>.
        </p>
        <pre data-include="schemas/manifest.json" />
      </section>
      <section>
        <h3 id="reconciliation-query-batch-json-schema">Reconciliation Query Batch Schema</h3>
	    <p>
	      The <a href="schemas/reconciliation-query-batch.json">reconciliation query batch schema</a> can be used to validate
	      the JSON serialization of any <a>reconciliation query batch</a>, i.e. the payload of a GET/POST to the reconciliation endpoint.
	   </p>
	   <pre data-include="schemas/reconciliation-query-batch.json" />
      </section>
      <section>
        <h3 id="reconciliation-result-batch-json-schema">Reconciliation Result Batch Schema</h3>
	    <p>
          The <a href="schemas/reconciliation-result-batch.json">reconciliation result batch schema</a> can be used to validate the JSON serialization of any <a>reconciliation result batch</a>.
        </p>
        <pre data-include="schemas/reconciliation-result-batch.json" />
      </section>
      <section>
        <h3>Data Extension Query Schema</h3>
        <p>
          The <a href="schemas/data-extension-query.json">data extension query schema</a> validates <a>data extension queries</a>.
        </p>
        <pre data-include="schemas/data-extension-query.json" />
      </section>
      <section>
        <h3>Data Extension Response Schema</h3>
        <p>
          The <a href="schemas/data-extension-response.json">data extension response schema</a> validates <a>data extension responses</a>.
        </p>
        <pre data-include="schemas/data-extension-response.json" />
      </section>
    </section>
  </body>
</html>
